### Container für Spring-managed Beans
Im Mittelpunkt einer Spring Anwendung steht eine besondere Datenstruktur, der Spring-Container.
Der Container hat drei zentrale Aufgaben. Er muss die Spring managed Beans:
1. anlegen
2. aufnehmen und verwalten
3. konfigurieren und Abhängigkeiten zwischen den Komponenten auflösen

Diese Komponenten lassen sich später aus dem Container herausnehmen und abfragen. 
Nicht alle Objekte befinden sich im Inneren des Spring-Containers, einige davon sind z.B.: Strings oder Daten aus einer Datenbank

### Container starten
<pre>
@SpringBootApplication
public class Kapitel2Application {
	public static void main(String[] args) {
		SpringApplication.run(Kapitel2Application.class, args);
	}
}
</pre>

Die run(...) Methode ist eine statische Methode der Klasse SpringApplication.
Dieser Methode werden zwei Informationen übergeben:
1. eine sogenannte Initialkonfiguration, das ist hier der Typ unserer eigenen Klasse 
2. die Argumente (args) aus der main(...)-Methode werden an die run(...)-Methode weitergeleitet. Spring, nimmt aus den Argumenten gewisse Konfigurationsinformationen heraus. Würde man dieses Argumente nicht weitergeben, käme Spring nicht an die Argumente heran, die man auf der Kommandozeile übergibt

### SpringApplication instanziieren
Die erste Alternative zu der statischen run(...)-Methode ist, dass man ein Objekt vom Typ SpringApplication aufbauen kann und später die Objektmethode run(...) einsetzen kann.
Vorteil daran ist, dass man beim SpringApplication-Objekt einige Einstellungen vornehmen kann.
(Die meisten Einstellungen macht man aber heutzutage über eine Konfigurationsdatei)
<pre>
@SpringBootApplication
public class Kapitel2Application {
	public static void main(String[] args) {
		SpringApplication springApplication = new SpringApplication(Kapitel2Application.class);
		springApplication.setHeadless(false);
		springApplication.setBannerMode(Banner.Mode.OFF);
		springApplication.setLogStartupInfo(false);
		springApplication.run(args);
	}
}
</pre>

Das obere Beispiel zeigt drei Einstellungen:
1. AWT-System wird deaktiviert → Anwendung läuft ohne GUI
2. Der Start Banner wird ausgeschaltet
3. Startinformationen werden abgeschaltet

### SpringApplicationBuilder
Eine weitere Variante ist der [SpringApplicationBuilder](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/builder/SpringApplicationBuilder.html) (das Aufbauen eines Objekts über das [Builder-Pattern](https://refactoring.guru/design-patterns/builder))  
Bei dem Builder Pattern werden zur Konfiguration keine parametrisierten Konstruktor oder Setter verwendet, sondern Methoden kaskadiert (verkettet) -> a().b().c()  
<pre>
public static void main(String[] args) {
		new SpringApplicationBuilder(Kapitel2Application.class)
				.headless(false)
				.bannerMode(Banner.Mode.OFF)
				.logStartupInfo(false)
				.run(args);
	}
</pre>

Die Unterschiede von einem SpringApplicationBuilder zu einer SpringApplication:   
- Der Builder hat nur Setter, und keine Getter
- Beim Builder lässt sich ein hierarchischer Kontext setzen

### Was die main(...) Methode macht
Die main(...)-Methode ruft von außen die run(...)-Methode auf, welche wiederum den Container hochfährt.  
Die main(...)-Methode blickt sozusagen von außen auf diesen Container mit den Spring-managed Beans.  

### Die run(...)-Methode und der ConfigurableApplicationContext (mit den Kontextmethoden)
Der Rückgabewert der run(...)-Methode ist der Applikationskontext. Dieser kann ich einer Variable gespeichert und später verwendet werden.  
[Hier die Dokumentation dazu](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ConfigurableApplicationContext.html)
<pre>

</pre>




