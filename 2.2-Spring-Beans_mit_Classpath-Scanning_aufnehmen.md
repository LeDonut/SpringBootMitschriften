### 2.2 Container mit Beans befüllen
Dafür gibt es zwei verschiedene Ansätze:
- deklaratives Arbeiten per Annotation (Container erkennt per SpringBoot-Magie selbstständig die Komponenten)
- manuell Registrieren über XML-Dateien

#### Abstraktion des eines Dateisystems: FileSystem

<pre>
@Component
public class FileSystem {
    private final Path root = Paths.get(System.getProperty("user.home")).resolve("fs");
    
    public FileSystem() {
        try {
            if (!Files.isDirectory(root)) {
                Files.createDirectory(root);
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
    
    public long getFreeDiskSpace() {
        return root.toFile().getFreeSpace();
    }
    
    public byte[] load(String filename) {
        try {
            return Files.readAllBytes(root.resolve(filename));
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
    
    public void store(String filename, byte[] bytes) {
        try {
            Files.write(root.resolve(filename), bytes);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
}
</pre>

- getFreeDiskSpace() liefert die freien Bytes, da Path keine Methode besitzt, um den Speicherplatz zu erfragen
- load() lädt eine Datei
- store() speichert ein byte-Array und löst ebenfalls relativ den Fad auf

#### @Component
Mit [`@Component`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html) sagen wir dem Framework, dass die Klasse eine Komponente ist und automatisch erkannt werden soll.  

<pre>
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {
 // ...
}
</pre>
Die Annotation ist selbst annotiert; dabei spricht man von sogenannten Meta-Annotationen.  
- `@Target`: bedeutet, dass @Component ausschließlich an Typdeklarationen festgemacht werden darf
- `@Retention`: sagt, dass die Annotation zur Laufzeit über Reflection zugänglich ist
- `@Documented`: besagt, dass das Setzen der Notation selbst in der Java-Dokumentation auftaucht
- `@Indexed`: zeigt an, dass das kommentierte Element einem Stereotyp für den Index darstellt

#### Aufbau der Annotation @SpringBootApplication
<pre>
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
    //...
}
</pre>

- `@Inherited`: zeigt an, dass eine annotierte Klasse oder Schnittstelle auch von den abgeleiteten Klassen geerbt wird
- `@SpringBootConfiguration`: kennzeichnet eine Klasse als Konfigurationsklasse für SpringBoot-Anwendungen
- `@EnableAutoConfiguration`: damit wird die Konfiguration von SpringBoot aktiviert, um die Beans und Abhängigkeiten automatisch zu konfigurieren
- `@ComponentScan`: diese Annotation weist Spring an, nach Spring-Beans (mit Annotation wie @Component, @Service, @Repository etc.) in einem bestimmten Paket oder Paketen zu suchen und sie zu registrieren

#### Die 'Wurzel' des Classpath-Scannings
Wird mit run(...) der Container gestartet, sucht das Spring Framework nach @Component-annotierten Typen.  
Nicht überall wird nach annotierten Klassen gesucht, es gibt Einschränkungen wo der Container mit der Suche beginnt.  
Standardmäßig beginnt der Container genau mit dem Paket der Hauptkonfiguration, wo sich die main(...).Methode befindet.  
Danach sucht er in allen Unterpaketen.  
Sollten die @Component-Klassen in anderen Paketen liegen, oder die Application-Klasse isoliert auf gleicher Ebene in einem Paket liegen, dann wird diese nichts finden und man muss das Classpath-Scanning präzise mit @ComponentScan steuern.  
(Typen sollten nie im Default-Package, also dem umbenannten Paket, stehen. Das ist ein schlechter Stil.)  

#### @Repository, @Service, @Controller
- `@Service`: diese Klasse führen normalerweise die Businesslogik aus
- `@Repository`: diese Klassen gehen in der Regel auf Datenspeicher
- `@Controller`: diese Klassen nehmen vom Frontend Anfragen entgegen
